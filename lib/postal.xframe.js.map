{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap b6ffe2fddd7b419feb75","webpack:///external {\"root\":\"_\",\"commonjs\":\"lodash\",\"commonjs2\":\"lodash\",\"amd\":\"lodash\"}","webpack:///./src/state.js","webpack:///external \"postal\"","webpack:///./src/XFrameClient.js","webpack:///./src/utils.js","webpack:///./src/index.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA,YAAI;AACJ;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC9DA,+C;;;;;;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kEAAqB;AACrB;AACA;;;;;;;AC1BA,+C;;;;;;;;;;;;ACAA;AACA;AACqB;;AAErB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;ACxCA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AChDA;AAAA;AACA;;AAOC;AACoB;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,6EAA6B;AAC7B,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,GAAG;AACN,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"postal.xframe.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"postal\"), require(\"lodash\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"postal\", \"lodash\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"postalXframe\"] = factory(require(\"postal\"), require(\"lodash\"));\n\telse\n\t\troot[\"postalXframe\"] = factory(root[\"postal\"], root[\"_\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_0__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b6ffe2fddd7b419feb75","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"_\",\"commonjs\":\"lodash\",\"commonjs2\":\"lodash\",\"amd\":\"lodash\"}\n// module id = 0\n// module chunks = 0","import _ from \"lodash\";\n\nexport let env = {\n\torigin: location.origin || location.protocol + \"//\" + location.host,\n\tisWorker: ( typeof window === \"undefined\" ) && postMessage && location,\n\t// I know, I KNOW. The alternative was very expensive perf & time-wise\n\t// so I saved you a perf hit by checking the stinking UA. Sigh.\n\t// I sought the opinion of several other devs. We all traveled\n\t// to the far east to consult with the wisdom of a monk - turns\n\t// out he didn\"t know JavaScript, and our passports were stolen on the\n\t// return trip. We stowed away aboard a freighter headed back to the\n\t// US and by the time we got back, no one had heard of IE 8 or 9. True story.\n\tuseEagerSerialize: /MSIE [8,9]/.test( navigator.userAgent )\n};\n\nconst defaults = {\n\tallowedOrigins: [ env.origin ],\n\tenabled: true,\n\tdefaultOriginUrl: \"*\",\n\tsafeSerialize: false\n};\n\nexport let state = {\n\tworkers: [],\n\tconfig: _.extend( {}, defaults ),\n\tdefaults\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/state.js\n// module id = 1\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"postal\"\n// module id = 2\n// module chunks = 0","import postal from \"postal\";\nimport _ from \"lodash\";\nimport { state, env } from \"./state\";\n\nexport default class XFrameClient extends postal.fedx.FederationClient {\n\n\tconstructor( ...args ) {\n\t\tsuper( ...args );\n\t\tthis.transportName = \"xframe\";\n\t}\n\n\tshouldProcess() {\n\t\tconst hasDomainFilters = !!state.config.allowedOrigins.length;\n\t\treturn state.config.enabled &&\n\t\t\t// another frame/window\n\t\t\t( ( this.options.origin === \"*\" || ( hasDomainFilters && _.contains( state.config.allowedOrigins, this.options.origin ) || !hasDomainFilters ) ) ||\n\t\t\t// worker\n\t\t\t( this.options.isWorker && _.contains( state.workers, this.target ) ) ||\n\t\t\t// we are in a worker\n\t\t\tenv.isWorker );\n\t}\n\n\tsend( packingSlip ) {\n\t\tif ( this.shouldProcess() ) {\n\t\t\tconst context = env.isWorker ? null : this.target;\n\t\t\tconst args = [ postal.fedx.transports.xframe.wrapForTransport( packingSlip ) ];\n\t\t\tif ( !this.options.isWorker && !env.isWorker ) {\n\t\t\t\targs.push( this.options.origin );\n\t\t\t}\n\t\t\tif ( !env.isWorker ) {\n\t\t\t\tif ( args.length === 1 ) {\n\t\t\t\t\tthis.target.postMessage( args[0] );\n\t\t\t\t} else {\n\t\t\t\t\tthis.target.postMessage( args[0], args[1] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.target.postMessage.apply( context, args );\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/XFrameClient.js\n// module id = 3\n// module chunks = 0","import _ from \"lodash\";\n\nexport function _memoRemoteByInstanceId( memo, instanceId ) {\n\tvar proxy = _.find( this.remotes, function( x ) {\n\t\treturn x.instanceId === instanceId;\n\t} );\n\tif ( proxy ) {\n\t\tmemo.push( proxy );\n\t}\n\treturn memo;\n}\n\nexport function _memoRemoteByTarget( memo, tgt ) {\n\tvar proxy = _.find( this.remotes, function( x ) {\n\t\treturn x.target === tgt;\n\t} );\n\tif ( proxy ) {\n\t\tmemo.push( proxy );\n\t}\n\treturn memo;\n}\n\nexport function _disconnectClient( client ) {\n\tclient.disconnect();\n}\n\nexport function safeSerialize( envelope ) {\n\tfor ( let [ key, val ] of entries( envelope ) ) {\n\t\tif ( typeof val === \"function\" ) {\n\t\t\tdelete envelope[ key ];\n\t\t}\n\t\tif ( _.isPlainObject( val ) ) {\n\t\t\tsafeSerialize( val );\n\t\t}\n\t\tif ( _.isArray( val ) ) {\n\t\t\t_.each( val, safeSerialize );\n\t\t}\n\t}\n\treturn envelope;\n}\n\nexport var entries = function*( obj ) {\n\tif ( [ \"object\", \"function\" ].indexOf( typeof obj ) === -1 ) {\n\t\tobj = {};\n\t}\n\tfor ( var k of Object.keys( obj ) ) {\n\t\tyield [ k, obj[ k ] ];\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = 4\n// module chunks = 0","const _ = require(\"lodash\")\nconst postal = require(\"postal\")\n\nimport {\n\t_memoRemoteByInstanceId,\n\t_memoRemoteByTarget,\n\t_disconnectClient,\n\tsafeSerialize\n} from \"./utils\";\nimport { state, env } from \"./state\";\nimport XFrameClient from \"./XFrameClient\";\n\nfunction listener() {\n\tplugin.routeMessage.apply( plugin, arguments );\n}\n\nfunction listenToWorker( worker ) {\n\tif ( !_.include( state.workers, worker ) ) {\n\t\tworker.addEventListener( \"message\", listener );\n\t\tstate.workers.push( worker );\n\t}\n}\n\nXFrameClient.getInstance = function getInstance( source, origin, instanceId ) {\n\tconst client = new XFrameClient( source, {\n\t\torigin: origin,\n\t\tisWorker: ( typeof Worker !== \"undefined\" && source instanceof Worker )\n\t}, instanceId );\n\tif ( client.options.isWorker ) {\n\t\tlistenToWorker( client.target );\n\t}\n\treturn client;\n};\n\nconst NO_OP = function() {};\n\nconst plugin = postal.fedx.transports.xframe = {\n\teagerSerialize: env.useEagerSerialize,\n\tXFrameClient: XFrameClient,\n\tconfigure: function( cfg ) {\n\t\tif ( cfg ) {\n\t\t\tstate.config = _.defaults( _.extend( state.config, cfg ), state.defaults );\n\t\t}\n\t\treturn state.config;\n\t},\n\tclearConfiguration: function() {\n\t\tstate.config = _.extend( {}, state.defaults );\n\t},\n\t//find all iFrames and the parent window if in an iframe\n\tgetTargets: env.isWorker ? function() {\n\t\treturn [ {\n\t\t\ttarget: {\n\t\t\t\tpostMessage: postMessage\n\t\t\t}\n\t\t} ]; // TO-DO: look into this...\n\t} : function() {\n\t\tconst targets = _.map( document.getElementsByTagName( \"iframe\" ), function( i ) {\n\t\t\tvar urlHack = document.createElement( \"a\" );\n\t\t\turlHack.href = i.src;\n\t\t\tlet origin = urlHack.protocol + \"//\" + urlHack.host;\n\t\t\t// The following condition fixes the IE issue of setting the origin while the iframe is 'empty':\n\t\t\t// if the iframe has no 'src' set to some meaningful url (at this very moment),\n\t\t\t// then the urlHack returns neither protocol nor host information.\n\t\t\tif ( origin === \"//\" ) {\n\t\t\t\torigin = null;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttarget: i.contentWindow,\n\t\t\t\torigin: origin || state.config.defaultOriginUrl\n\t\t\t};\n\t\t} );\n\t\tif ( window.parent && window.parent !== window ) {\n\t\t\ttargets.push( {\n\t\t\t\ttarget: window.parent,\n\t\t\t\torigin: \"*\"\n\t\t\t} );\n\t\t}\n\t\treturn targets.concat( state.workers );\n\t},\n\tremotes: [],\n\twrapForTransport: env.useEagerSerialize ? function( packingSlip ) {\n\t\treturn JSON.stringify( {\n\t\t\tpostal: true,\n\t\t\tpackingSlip: packingSlip\n\t\t} );\n\t} : function( packingSlip ) {\n\t\treturn {\n\t\t\tpostal: true,\n\t\t\tpackingSlip: packingSlip\n\t\t};\n\t},\n\tunwrapFromTransport: function( msgData ) {\n\t\tif ( typeof msgData === \"string\" && ( env.useEagerSerialize || msgData.indexOf( '\"postal\":true' ) !== -1 ) ) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse( msgData );\n\t\t\t} catch ( ex ) {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t} else {\n\t\t\treturn msgData;\n\t\t}\n\t},\n\trouteMessage: function( event ) {\n\t\t// source = remote window or worker?\n\t\tconst source = event.source || event.currentTarget;\n\t\tconst parsed = this.unwrapFromTransport( event.data );\n\t\tif ( parsed.postal ) {\n\t\t\tvar remote = _.find( this.remotes, function( x ) {\n\t\t\t\treturn x.target === source;\n\t\t\t} );\n\t\t\tif ( !remote ) {\n\t\t\t\tremote = XFrameClient.getInstance( source, event.origin, parsed.packingSlip.instanceId );\n\t\t\t\tthis.remotes.push( remote );\n\t\t\t}\n\t\t\tremote.onMessage( parsed.packingSlip );\n\t\t}\n\t},\n\tsendMessage: function( env ) {\n\t\tlet envelope = env;\n\t\tif ( state.config.safeSerialize ) {\n\t\t\tenvelope = safeSerialize( _.cloneDeep( env ) );\n\t\t}\n\t\t_.each( this.remotes, function( remote ) {\n\t\t\tremote.sendMessage( envelope );\n\t\t} );\n\t},\n\tdisconnect: function( options ) {\n\t\toptions = options || {};\n\t\tconst clients = options.instanceId ?\n\t\t\t// an instanceId value or array was provided, let's get the client proxy instances for the id(s)\n\t\t\t_.reduce( _.isArray( options.instanceId ) ? options.instanceId : [ options.instanceId ], _memoRemoteByInstanceId, [], this ) :\n\t\t\t// Ok so we don't have instanceId(s), let's try target(s)\n\t\t\toptions.target ?\n\t\t\t\t// Ok, so we have a targets array, we need to iterate over it and get a list of the proxy/client instances\n\t\t\t\t_.reduce( _.isArray( options.target ) ? options.target : [ options.target ], _memoRemoteByTarget, [], this ) :\n\t\t\t\t// aww, heck - we don't have instanceId(s) or target(s), so it's ALL THE REMOTES\n\t\t\t\tthis.remotes;\n\t\tif ( !options.doNotNotify ) {\n\t\t\t_.each( clients, _disconnectClient, this );\n\t\t}\n\t\tthis.remotes = _.without.apply( null, [ this.remotes ].concat( clients ) );\n\t},\n\tsignalReady: function( targets, callback ) {\n\t\ttargets = _.isArray( targets ) ? targets : [ targets ];\n\t\ttargets = targets.length ? targets : this.getTargets();\n\t\tcallback = callback || NO_OP;\n\t\t_.each( targets, function( def ) {\n\t\t\tif ( def.target ) {\n\t\t\t\tdef.origin = def.origin || state.config.defaultOriginUrl;\n\t\t\t\tlet remote = _.find( this.remotes, function( x ) {\n\t\t\t\t\treturn x.target === def.target;\n\t\t\t\t} );\n\t\t\t\tif ( !remote ) {\n\t\t\t\t\tremote = XFrameClient.getInstance( def.target, def.origin );\n\t\t\t\t\tthis.remotes.push( remote );\n\t\t\t\t}\n\t\t\t\tremote.sendPing( callback );\n\t\t\t}\n\t\t}, this );\n\t},\n\taddEventListener: env.isWorker ? function() {\n\t\taddEventListener( \"message\", listener );\n\t} : function( eventName, handler, bubble ) {\n\t\t// in normal browser context\n\t\tif ( typeof window !== \"undefined\" && typeof window.addEventListener === \"function\" ) {\n\t\t\twindow.addEventListener( eventName, handler, bubble );\n\t\t} else {\n\t\t\tthrow new Error( \"postal.xframe only works with browsers that support window.addEventListener\" );\n\t\t}\n\t},\n\tlistenToWorker: listenToWorker,\n\tstopListeningToWorker: function( worker ) {\n\t\tif ( worker ) {\n\t\t\tworker.removeEventListener( \"message\", listener );\n\t\t\tstate.workers = _.without( state.workers, worker );\n\t\t} else {\n\t\t\twhile ( state.workers.length ) {\n\t\t\t\tstate.workers.pop().removeEventListener( \"message\", listener );\n\t\t\t}\n\t\t}\n\t}\n};\n\nplugin.addEventListener( \"message\", listener, false );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}